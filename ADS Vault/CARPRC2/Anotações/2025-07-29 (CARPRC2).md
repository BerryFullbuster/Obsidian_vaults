
public - acessado por qualquer
static - não precisa ser instanciado
void - não retorna nada

SINTAXE BÁSICA DO JAVA
- Estrutura de um programa
- [[Tipos primitivos]]
- Operadores
- Estruturas de controle

Classes e objetos
- Classe -> Modelo
- Objeto -> Instância

Encapsulamento e Herança
- Modificadores de acesso(private, protected, public)
- Gatters e Setters
- extends para reutilização de código
- Polimorfismo simples com sobrescrita (@Override)

Classe abstratas e interface
- Classe Abstrata: (extends)
	- Não pode ser instanciada diretamente.
	- Serve como **modelo** para subclasses.
	- Pode ter **métodos concretos** e **métodos abstratos** (sem corpo).
	- Subclasses precisam implementar os métodos abstratos.
- Conceito de Interface: (implements)
	- Um **contrato**: só contém métodos (assinaturas) e constantes.
	- Uma classe pode implementar várias interfaces.
	- Garante que diferentes classes tenham o mesmo conjunto de métodos.

Tratamento de exceções
- Trata para:
	- Lidar com erros em tempo de execução sem quebrar o programa.
	- Permite reagir a problemas de forma controlada.
	- Evita mensagens de erro inesperadas para o usuários final.
- Blocos principais
	- try - onde você coloca o código que pode gerar exceção
	- catch - onde você trata a exceção especifica
	- finally - (opcional) executa sempre, mesmo com exceção

Propagando exceções
- throws
	- Usado no **método** para dizer que ele pode lançar uma exceção
	- Obriga quem chama o método a tratar (try/catch) ou também propagar

exceções personalizadas
	- Podemos criar uma classe que estende Exception (checked) ou RuntimeExpection (unchecked).
	- Para situações específicas do nosso sistema.

Manipulação de Arquivos
- Por que trabalhar com arquivos
	- Salvar e recuperar dados persistentes.
	- Ler configurações, registros ou resultados de programas.
	- Interagir com dados externos sem depender apenas de banco de dados.
- java.io (API clássica)
	- File - representação do caminho do arquivo/diretório
	- FileReader / FileWriter - leitura/escrita de caracteres.
	- BufferedReader / BufferedWriter - leitura/escrita com buffer (mais eficiente)
- Pacote java.nio.file:
	- Substitui java.io.File com mais segurança e flexibilidade
	- Principais classes e interfaces:
	- 

| Classe             | Descrição                                                     |
| ------------------ | ------------------------------------------------------------- |
| Path               | Representa um caminho de arquivo ou diretório (abstrato)      |
| Paths              | Fábrica de objetos Path                                       |
| Files              | Operações utilitárias (ler, escrever, copiar, mover, deletar) |
| StandardOpenOption | Controla como arquivos são abertos                            |
| DirectoryStream    | Para iterar sobre diretórios                                  |

Formas de leitura
- Linha por linha:
```
Path caminho = Paths.get("dados.txt");
List<String> linhas = Files.readAllLines(caminho);
for (String linha : linhas){
	System.out.println(linha);
}
```
- Com Stream<String\>:
```
Files.lines(Paths.get("dados.txt")).forEach(System.out::println);
```

- BufferedWriter:
```
try(BuferedWriter writer = Files.newBufferedWriter(Paths.get("saida.txt"))){
writer.write("Olá mundo!");
writer.newLine();
writer.write("Outra linha.");
}
```
- PrinterWriter
```
try(BuferedWriter writer = new PrintWriter(Files.newBufferedWriter(Paths.get("saida.txt")))){
writer.println("Escrevendo com PrintWriter");
writer.printf("Valor: %.2f%n", 12.34);
}
```
- Linhas:
```
import java.nio.file.* ;
import java.io.IOException;
import java.util.List;

public class EscritasSimples {
	public static void main(String[] args) throws IOException{
		 Path caminho = Paths.get("saida.txt");
		 List<String/> linhas = List.of("Linha 1", "Linha 2", "Linha 3");

			Files.write(caminho, linhas); //escreve todas as Linhas no arquivo
	}
}
```

- Bytes:
```
byte[] dados = {10, 20, 30, 40};
Files.write(Path.get("dados.bin"), dados);
```

Outros exemplos úteis

//copiar um arquivo
Files.copy(Paths.get("origem.txt"), Paths.get("copia.txt"), StandardCopyOption.REPLACE_EXISTING):

//Mover um arquivo
Files.move(Paths.get("copia.txt"), Paths.get("arquivos/copia.txt"));

//Apagar
Files.delateIfExistis(Path.get("dados.txt"));

Organização de projetos em java
- Estrutura básica de um Projeto Java:
- bin/ ou build/ - pasta onde são gerados os arquivos compilados (class)
- lib/ - pasta para bibliotecas externas (.jar)
- doc/ - documentação (opcional).
- outros arquivos README.md, MANIFEST,MF, arquivos de configuração

pacotes em java
- Usados para organizar classes de forma hierárquica
- Evitam conflitos de nomes.
- Convenção de nomeação: geralmente br.com.empresa.projeto.
```
package br.com.meuprojeto.util;

public class MinhaClasse{
//codigo
}
```

Organização no Netbeans IDE

- O NetBeams cria automaticamente a estrutura de pastas:
	- Source Packages - pasta src com pacotes.
	- Libraries - gerencia bibliotecas (.jar) adicionadas ao projeto.
	- Test Packages - para testes unitários, separados dos códigos fonte
- Dicas práticas para organização:
	- Sempre utilize pacotes para separar funcionalidades (ex: model, view, controller)
	- Nomeie pacotes com conveção para evitar conflitos.
	- Separe arquivos fonte, testes e libs para facilitar manutenção
	- Use o NetBeans para automatizar compilações, execuções e gerenciamento de bibliotecas


Apresentação:


![[Aula 01.pdf]]